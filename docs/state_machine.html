<!DOCTYPE html>

<html>
<head>
  <title>State machine support for task.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="channel.html">
                channel.js
              </a>
            
              
              <a class="source" href="state_machine.html">
                state_machine.js
              </a>
            
              
              <a class="source" href="task.html">
                task.js
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <h1 id="state-machine-support-for-task-js">State machine support for task.js</h1>
<p>This file contains miscellaneous state machine management code
that is used by the code generated by the <code>task</code> macro in task.js.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">State</span><span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">this</span>.id = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">this</span>.args = [<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>];
    <span class="hljs-keyword">this</span>.unwinding = [];
    <span class="hljs-keyword">this</span>.phi = [];
    <span class="hljs-keyword">this</span>.installed_catches = {};
    <span class="hljs-keyword">this</span>.waiting = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">this</span>.isFinished = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">this</span>.isUnwinding = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">this</span>.abort_with_error = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">controlAPIMaker</span><span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">var</span> state_machine = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.create({}, {
        abort: {
            value: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err)</span> {</span>
                <span class="hljs-keyword">if</span> (state_machine.state.waiting &gt; <span class="hljs-number">0</span>) {
                    state_machine.state.abort_with_error = err;
                } <span class="hljs-keyword">else</span> {
                    state_machine.callback(err);
                }
            }
        },
        isWaiting: {
            get: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
                <span class="hljs-keyword">return</span> state_machine.state.waiting &gt; <span class="hljs-number">0</span>;
            }
        },
        isFinished: {
            get: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
                <span class="hljs-keyword">return</span> state_machine.state.isFinished;
            }
        }
    });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">StateMachine</span><span class="hljs-params">(context, callback, fn)</span> {</span>

    <span class="hljs-keyword">this</span>.state = <span class="hljs-keyword">new</span> State();
    <span class="hljs-keyword">this</span>.fn = fn;
    <span class="hljs-keyword">this</span>.context = context;
    <span class="hljs-keyword">this</span>.finalCallback = callback;
    <span class="hljs-keyword">this</span>.boundStep = <span class="hljs-keyword">this</span>.step.bind(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">this</span>.boundUnwind = <span class="hljs-keyword">this</span>.unwind.bind(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">this</span>.cachedJumpTable = {};
    <span class="hljs-keyword">this</span>.controlAPIMaker = controlAPIMaker.bind(<span class="hljs-keyword">this</span>);

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
}

StateMachine.prototype.start = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">this</span>.goTo(<span class="hljs-number">1</span>);
};

StateMachine.prototype.step = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">this</span>.state.waiting--;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state.abort_with_error) {
        <span class="hljs-keyword">this</span>.state.abort_with_error = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.fn.call(<span class="hljs-keyword">this</span>.context, <span class="hljs-keyword">this</span>.state.abort_with_error);
    }
    <span class="hljs-keyword">this</span>.fn.apply(<span class="hljs-keyword">this</span>.context, <span class="hljs-keyword">this</span>.state.args);
};

StateMachine.prototype.goTo = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(id)</span> {</span>
    <span class="hljs-keyword">this</span>.state.id = id;
    <span class="hljs-keyword">this</span>.state.waiting++;
    process.nextTick(<span class="hljs-keyword">this</span>.boundStep);
};

StateMachine.prototype.thenTo = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(id)</span> {</span>
    <span class="hljs-keyword">var</span> done = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">this</span>.state.waiting++;
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
        <span class="hljs-keyword">var</span> _self = self;
        <span class="hljs-keyword">var</span> _state = _self.state;
        _state.waiting--;
        <span class="hljs-keyword">if</span> (_state.abort_with_error) {
            <span class="hljs-keyword">return</span> _self.fn.call(_self.context, _state.abort_with_error);
        }
        <span class="hljs-keyword">if</span> (!done) {
            done = <span class="hljs-literal">true</span>;
            _state.id = id;
            _self.fn.apply(_self.context, <span class="hljs-built_in">arguments</span>); 
        } <span class="hljs-keyword">else</span> {
            console.error(<span class="hljs-string">'Callback called repeatedly!'</span>);
        }
    };
};

StateMachine.prototype.callback = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">this</span>.state.args = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>);
    process.nextTick(<span class="hljs-keyword">this</span>.boundUnwind);
};

StateMachine.prototype.unwind = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state.unwinding.length &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">var</span> where = <span class="hljs-keyword">this</span>.state.unwinding.pop();
        <span class="hljs-keyword">this</span>.state.isUnwinding = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span> (where.isError) {
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state.args[<span class="hljs-number">0</span>]) {
                <span class="hljs-keyword">this</span>.goTo(where.step);
            } <span class="hljs-keyword">else</span> {
                process.nextTick(<span class="hljs-keyword">this</span>.boundUnwind);
            }
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (where.fn) {
                where.fn(<span class="hljs-keyword">this</span>.unwind);
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">this</span>.goTo(where.step);
            }
        }
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.state.isFinished) {
        <span class="hljs-keyword">this</span>.state.waiting = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">this</span>.state.isFinished = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">this</span>.finalCallback &amp;&amp; <span class="hljs-keyword">this</span>.finalCallback.apply(<span class="hljs-keyword">this</span>.context, <span class="hljs-keyword">this</span>.state.args);
    }
};

StateMachine.prototype.unwindNextTick = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    process.nextTick(<span class="hljs-keyword">this</span>.boundUnwind);
};

StateMachine.prototype.pushCleanupAction = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(fn, args)</span> {</span>
    <span class="hljs-keyword">var</span> callbackPos = args.length;
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
    self.state.unwinding.push({
        cleanup: <span class="hljs-literal">true</span>,
        fn: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(cb)</span> {</span>
            args[callbackPos] = cb;
            fn.apply(self.context, args);
        }
    });
};

StateMachine.prototype.pushCleanupStep = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(id)</span> {</span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.state.installed_catches[id]) {
        <span class="hljs-keyword">this</span>.state.unwinding.push({cleanup: <span class="hljs-literal">true</span>, step: id});
        <span class="hljs-keyword">this</span>.state.installed_catches[id] = <span class="hljs-literal">true</span>;
    }
};

StateMachine.prototype.pushErrorStep = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(id)</span> {</span>
    <span class="hljs-keyword">this</span>.state.unwinding.push({isError: <span class="hljs-literal">true</span>, step: id});
};

StateMachine.prototype.pushPhi = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(id)</span> {</span>
    <span class="hljs-keyword">this</span>.state.phi.push(id);
};

StateMachine.prototype.phi = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">this</span>.goTo(<span class="hljs-keyword">this</span>.state.phi.pop());
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">JumpTable</span><span class="hljs-params">(sm, id, cases, blockSizes)</span> {</span>
    <span class="hljs-keyword">this</span>.state_machine = sm;
    <span class="hljs-keyword">this</span>.id = id;
    <span class="hljs-keyword">this</span>.cases = cases;
    <span class="hljs-keyword">this</span>.blockSizes = blockSizes;
    <span class="hljs-keyword">this</span>.stepIDs = [];
    <span class="hljs-keyword">this</span>.beyondID = id;

    <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, sum = id + <span class="hljs-number">1</span>, ci;
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; blockSizes.length; ++i) {
        ci = cases[i];
        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; ci.length; ++j) {
            <span class="hljs-keyword">this</span>.stepIDs[ci[j]] = sum;
        }
        sum += <span class="hljs-number">1</span> + blockSizes[i]; <span class="hljs-comment">// +1 for the additional "phi"</span>
    }

    <span class="hljs-keyword">this</span>.beyondID = sum;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
}

JumpTable.prototype.jumpToCase = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(caseVal)</span> {</span>
    <span class="hljs-keyword">this</span>.state_machine.pushPhi(<span class="hljs-keyword">this</span>.beyondID);
    <span class="hljs-keyword">var</span> stepID = <span class="hljs-keyword">this</span>.stepIDs[caseVal];
    <span class="hljs-keyword">if</span> (!stepID) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Unhandled case '"</span> + caseVal + <span class="hljs-string">"' at step "</span> + <span class="hljs-keyword">this</span>.id);
    }
    <span class="hljs-keyword">this</span>.state_machine.goTo(stepID);
};

StateMachine.prototype.jumpTable = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(id, cases, blockSizes)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>cases[i] is an array of case values that all map
to the same block whose size is given by blockSizes[i].</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (!cases) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.cachedJumpTable[id];
    }

    console.assert(cases.length === blockSizes.length);

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.cachedJumpTable[id] = <span class="hljs-keyword">new</span> JumpTable(<span class="hljs-keyword">this</span>, id, cases, blockSizes);
};


module.exports = StateMachine;</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
